 /* Main.c file generated by New Project wizard
 *
 * Created:   Sun Mar 21 2021
 * Processor: PIC16F887
 * Compiler:  MPLAB XC8
 */
#include <xc.h>
#include <sensors.c>
#include <lcd.c>

// Configuration bits
#pragma config FOSC = INTRC_NOCLKOUT // uses internal oscillator and Ra7 and Ra6 can be used as i/o pins
#pragma config WDTE = OFF // watchdog timer disabled
#pragma config PWRTE = OFF //power-up timer disabled
#pragma config MCLRE = OFF // Re3 used as master clear reset
#pragma config CP = OFF // code protection disabled
#pragma config CPD = OFF// data code protection disabled
#pragma config BOREN = OFF // only mclr reset
#pragma config IESO = OFF // two speed  start-up mode disabled due to internal osc use
#pragma config FCMEN = OFF // we use internal oscillator no need for external oscillator checking
#pragma config LVP = OFF // RE3 as digital I/O MCLR needs to be used for programming but we use serial tool 

#pragma config BOR4V = BOR40V // setting brown out reset to 4 V , if vdd decreases below that value it will initiate a reset
#pragma config WRT = OFF // write protection off

#define _XTAL_FREQ 8000000 // parameter for delay functions

#define LED_PIN     RA0
#define BUZZER_PIN RA2
#define NEXT_BUTTON_PIN RB0
#define CONFIRM_BUTTON_PIN RB1
#define CANCEL_BUTTON_PIN RB2
#define SET_BUTTON_PIN RB3
#define LEFT_BUTTON_PIN RB5
#define RIGHT_BUTTON_PIN RB4

#define LDR_PIN_AN 5
#define LM35DZ_PIN_AN 6
#define HCZH8A_PIN_AN 7

//Function declaration

void interrupt _buttons(void);
void initialise_uC();
unsigned int read_data_ADC(char);
char debounce_buttons_function(char);
void print_text_to_lcd(char* , char*);
//////////////////////////////////////////////////////////////FUNCTIONS
///TIMER1
char clock_time_tmr1[] = "TIME: 00:00:00";
char clock_date_tmr1[]  = "DATE: 01/01/2021";
unsigned long timer1_tick = 0;
char tmr1_time_set =0;

char alarm_tmr1_vars[2][6]={ {0,0,0,1,1,21} , {0,0,0,0,0,0}};
char set_lrm_fnc = 0;

void convert_rtc_variables(void);

//SENSORS variables declaration
unsigned int lm35dz_data =0;


unsigned char Temperature_1st_byte, Temperature_2nd_byte, RelHumid_1st_byte, RelHumid_2nd_byte, CheckSum ;//8bits of data for each segment
char Digital_Temperature[] ="Temp = 11.11 C ";
char Digital_RelHumid[] ="R.H. = 11.11 %";   
char Analog_Temperature_Text[]="Temp = 11.11  C";
char Analog_RelHumid_Text[]="R.H = 11.11 %";

//Sensors functions

void start_dht11(void);
char Check_Response_from_DHT11(void);
char read_data_from_dht11(unsigned char*);

float hcz_h8a_calculate_humidity(unsigned int, float);
////////////////////////////////////LCD\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//lcd basic functions
void init_LCD(void);
void lcd_goto(unsigned char pos);
void lcd_puts(char * s);
void lcd_putch(char c);
void lcd_clear(void);

///////////////////////////////////////Main Menu\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

char next_button_nr = 0;
char break_from_functionality_loop = 0;
char confirm_pressed = 0;
void functionality_1_LightCheck(void);
void functionality_2_DigitalTemperature(void);
void functionality_3_Analog_Temperature_Humidity(void);
void functionality_4_Alarm_Clock(void);

//Main Menu Buttons variables

void main() {
    initialise_uC();
    init_LCD();
    __delay_ms(200);
    print_text_to_lcd((char*)"   GREETINGS!",(char *)"   Press Next!");
    while(1){   
	for(char chk_lrm_ind=6;chk_lrm_ind>1;chk_lrm_ind--) {
	    if(alarm_tmr1_vars[1][chk_lrm_ind-1]!=alarm_tmr1_vars[0][chk_lrm_ind-1]) chk_lrm_ind=1;
	    if(chk_lrm_ind==2) {
		while(CANCEL_BUTTON_PIN) {
		  LED_PIN=1;	
		  BUZZER_PIN =1;
		  __delay_ms(500);
		  LED_PIN=0;	
		  BUZZER_PIN =0;
		  __delay_ms(500);
		}
		alarm_tmr1_vars[1][1]--;
	    }		
	}
	if(!CANCEL_BUTTON_PIN) {
	    if(debounce_buttons_function(CANCEL_BUTTON_PIN)) {
		while(!CANCEL_BUTTON_PIN);
		if(confirm_pressed&&next_button_nr==2){
		     TMR1ON=1;
		     timer1_tick+=TMR1/1000;
		     TMR1=64536;// -> 65535->0
		}
		confirm_pressed=0;
		next_button_nr=0;
		print_text_to_lcd((char*)"   GREETINGS!",(char *)"   Press Next!"); 
	    }
	}
	if(!NEXT_BUTTON_PIN) {
	    if(debounce_buttons_function(NEXT_BUTTON_PIN)) {
		while(!NEXT_BUTTON_PIN);
		next_button_nr++;
		if(next_button_nr==5) next_button_nr=1;
		switch(next_button_nr) {
		  case 1 :print_text_to_lcd((char*)"1.Light Check",(char *)"Next or Confirm");break;// waiting for next button press or confirm
		  case 2: print_text_to_lcd((char*)"2.DHT11 Temp&RH",(char *)"Next or Confirm");break;
		  case 3: print_text_to_lcd((char*)"3.Analog Temp&RH",(char *)"Next or Confirm");break;
		  case 4:print_text_to_lcd((char*)"4.  Alarm Clock ",(char *)"Next or Confirm");break;
		}
	    }
	}
	if(!CONFIRM_BUTTON_PIN) {
	    if(debounce_buttons_function(CONFIRM_BUTTON_PIN)) {		
		while(!CONFIRM_BUTTON_PIN);
		if(next_button_nr) confirm_pressed = 1;
	    }
	}
	if(confirm_pressed) {
	    if(next_button_nr==4) functionality_4_Alarm_Clock();
	    else {
		switch(next_button_nr) {	
		     case 1:functionality_1_LightCheck();break;
		     case 2:functionality_2_DigitalTemperature();break;
		     case 3:functionality_3_Analog_Temperature_Humidity();break;
		}
		__delay_ms(3000);
	    }
	}
	// Increment Clock Variables
	if(tmr1_time_set==1) {
	    if(timer1_tick>=999) {
		if(timer1_tick==999) {
		     timer1_tick=0;
		     alarm_tmr1_vars[0][0]++;
		}
		else {	
		     alarm_tmr1_vars[0][0]+=timer1_tick/1000;
		     timer1_tick=timer1_tick%999;
		}
		if(alarm_tmr1_vars[0][0]>=60) {
		     alarm_tmr1_vars[0][1]+=alarm_tmr1_vars[0][0]/60;
		     alarm_tmr1_vars[0][0]=alarm_tmr1_vars[0][0]%60;
		}
		if(alarm_tmr1_vars[0][1]==60) {
		     alarm_tmr1_vars[0][2]++;
		     alarm_tmr1_vars[0][1]=0;
		}
		if(alarm_tmr1_vars[0][2]==24) {
		     alarm_tmr1_vars[0][3]++;
		     alarm_tmr1_vars[0][2]=0;
		}														
		if(alarm_tmr1_vars[0][3]==(32-((3-((alarm_tmr1_vars[0][5]%4)==0))*(alarm_tmr1_vars[0][4]==2)-1*(alarm_tmr1_vars[0][4]>=3&&((alarm_tmr1_vars[0][4]-1)%2))))) {
		     alarm_tmr1_vars[0][4]++;
		     alarm_tmr1_vars[0][3]=1;
		}
		if(alarm_tmr1_vars[0][4]==12) {
		     alarm_tmr1_vars[0][5]++;
		     alarm_tmr1_vars[0][4]=1;
		}
		convert_rtc_variables();
		if(next_button_nr==4&&confirm_pressed) 
		     print_text_to_lcd(clock_time_tmr1,clock_date_tmr1);
	    }
	}
     }
}

//*************************************Initialisation function*****************************************************

void initialise_uC() {
   // Setting the internal Oscillator to 8Mhz
   SCS =1; // setting the osccon bit SCS to 1 so it uses internal osc for system clock
   OSCCONbits.IRCF=0x07;// IRCF bits are 111 associated to the value of 8MHZ for internal osc

///////////////////////   //Port initialisation
    PORTA=0x00;
    PORTB=0x00 ; //clear port b
    PORTD=0x00 ; //clear port d
    TRISA=0x00;
    TRISD =0x00 ; //portd as output
    TRISB=0x3F ;  //Rb3->RB7 as output RB0->RB2 as input
///////////////////ADC Config
    ANSELH=0;
    ANSEL=0xE0; // 0b11100000 an7, an6, an5 are selected
    //ADCON1 register bits 
    ADFM =1; // the result of ADRESL AND ANDRESH COMBINEDD STRTS FROM BIT 0
    //ADCON0 register bits
    ADCON0bits.ADCS=0X02;// 8Mhz as Device frequency , 010 => 4us clock period         
    //Start ADC
    ADON = 1; 
//Interrupt + Pullup 
    PEIE=1;
    GIE = 1;
    // global interrupt enable on in order to pass the interrupt to the uC
    nRBPU= 0 ;   // clearing global negated rbpu bit of option register to select individual pullup resistors for interrupt pins
    WPUB0=0x3F ; // setting pullup resistors for rb0,1,2
    OPTION_REG = 0b00000111;//T = 128us 
    TMR0IF = 0;			// 
    TMR0 = 101;	  		// ; pana la maxim (255) 
    TMR0IE = 1;
///////////////////     TIMER 1 ->   check response for DHT11  clock
    T1CON = 0x10 ; // 1:2 prescaler => Fosc/4/2 = 1Mhz so 1uS per tick TMR1CS = 0
    TMR1H = 0;
    TMR1L = 0; 
    TMR1ON=0;
    TMR1IE=1;
}

void interrupt _ISR_interrupt_timers(void) {
   if(TMR0IF) {
      TMR0IF=0;
      if(confirm_pressed&&next_button_nr==2) {
	 TMR0=178 ;
	 timer1_tick+=10;
      }
      else TMR0=100;	
   }
   if(TMR1IF) {
      TMR1IF=0;
      TMR1+=64536;//10000 us => 10ms
      timer1_tick++;
   }
}

void functionality_1_LightCheck()
{  
  //LDR read from ADC
   unsigned int ldr_data = read_data_ADC(LDR_PIN_AN);	
   //Resistance of LDR 
   if(ldr_data>512) {	
      print_text_to_lcd((char*)"It appears to be",(char*)" dark outside. ");
      LED_PIN=1;
   }
   else {
      print_text_to_lcd((char*)"It appears to be",(char *)"  light outside.");
      LED_PIN=0;
   }
 }

void functionality_2_DigitalTemperature() {
    start_dht11();	
    if(Check_Response_from_DHT11()) {   
    // read_dataa_from_dht11 saves data and returns 1 if it's timeout error
	 if(read_data_from_dht11(&RelHumid_1st_byte) || read_data_from_dht11(&RelHumid_2nd_byte) || read_data_from_dht11(&Temperature_1st_byte) || read_data_from_dht11(&Temperature_2nd_byte) || read_data_from_dht11(&CheckSum)) {
	    print_text_to_lcd((char*)"Time out error",(char *)"");
	 }
	 else if(CheckSum == ((RelHumid_1st_byte+RelHumid_2nd_byte+Temperature_1st_byte+Temperature_2nd_byte) &0xFF)) {
		Digital_Temperature[7] = (Temperature_1st_byte/ 10 + '0');
		Digital_Temperature[8] = (Temperature_1st_byte%10 + '0');
	        Digital_Temperature[10] = (Temperature_2nd_byte /10 +'0');
	        Digital_Temperature[11] = (Temperature_2nd_byte%10 +'0');
	        Digital_Temperature[12] = 223;
	        Digital_RelHumid[7] = ( RelHumid_1st_byte/10 + '0');
		Digital_RelHumid[8] = ( RelHumid_1st_byte%10 + '0');
		Digital_RelHumid[10] = (RelHumid_2nd_byte/10 +'0');
	        Digital_RelHumid[11] = (RelHumid_2nd_byte%10 +'0');		
		print_text_to_lcd(Digital_Temperature,Digital_RelHumid);
	}
   }
   TMR1ON=0;
}

void functionality_3_Analog_Temperature_Humidity() {
	
	lm35dz_data = read_data_ADC(LM35DZ_PIN_AN);// returneaza valorea de la adc 
	float analog_temperature_value = lm35dz_data*0.48875855;///  5.0 /1023 gives the accuracy of 4.88mv per increment , multiply by the number of increments then multiply by 100 to get temperature in celsius
	Analog_Temperature_Text[7] = (int)(analog_temperature_value/10)%10 + '0';
	Analog_Temperature_Text[8] = (int)(analog_temperature_value)%10 + '0';
	Analog_Temperature_Text[10] = (int)(analog_temperature_value*10)%10 + '0';
	Analog_Temperature_Text[11] = (int)(analog_temperature_value*100)%10 + '0';
	Analog_Temperature_Text[12] = 223; 
	if(analog_temperature_value>=5&&analog_temperature_value<=60) {
		float analog_humidity_value = hcz_h8a_calculate_humidity(read_data_ADC(HCZH8A_PIN_AN),analog_temperature_value);
		Analog_RelHumid_Text[6] = (int)(analog_humidity_value/10)%10 + '0';
		Analog_RelHumid_Text[7] = (int)(analog_humidity_value)%10 + '0';
		Analog_RelHumid_Text[9] = (int)(analog_humidity_value*10)%10 + '0';
		Analog_RelHumid_Text[10] = (int)(analog_humidity_value*100)%10 + '0';
		 //display the values
		print_text_to_lcd(Analog_Temperature_Text,Analog_RelHumid_Text);
    }
	else {
				print_text_to_lcd(Analog_Temperature_Text,(char *)"RH = Loading...");
	}	
}

void functionality_4_Alarm_Clock()
{	
	if(!SET_BUTTON_PIN) {
		if(debounce_buttons_function(SET_BUTTON_PIN)) {
			while(!SET_BUTTON_PIN);
				__delay_ms(2000);
				if(!SET_BUTTON_PIN) {
					if(debounce_buttons_function(SET_BUTTON_PIN)) {
						while(!SET_BUTTON_PIN);
						print_text_to_lcd((char*)"5. Alarm Set",(char*)"Loading....");
						__delay_ms(2000);
						print_text_to_lcd(clock_time_tmr1,clock_date_tmr1);
						set_lrm_fnc = 1;
						for(char idx_rtc_vars=0;idx_rtc_vars<=5;idx_rtc_vars++)
							alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars] =alarm_tmr1_vars[0][idx_rtc_vars];
					}
				}
				// time to get here
				char idx_rtc_vars=5;
				if(!set_lrm_fnc)TMR1ON=0;
					tmr1_time_set=0;
					char param_poz_x_y=0xCE ;
					while(idx_rtc_vars>=1) {
						if(!SET_BUTTON_PIN) {
							if(debounce_buttons_function(SET_BUTTON_PIN)) {
								while(!SET_BUTTON_PIN);
								idx_rtc_vars--;
								switch(idx_rtc_vars) {
									case 1: param_poz_x_y = 0x89;break;
									case 2: param_poz_x_y = 0x86;break;
									case 3: param_poz_x_y = 0xC6;break;
									case 4: param_poz_x_y = 0xC9;break;
								}	
							}
						}
						if(!LEFT_BUTTON_PIN) {
							if(debounce_buttons_function(LEFT_BUTTON_PIN)) {
								if(idx_rtc_vars<3) 	{ 
									if(alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars])alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]--;
								}
								else {
									if(alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]>1)alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]--;
								}
								lcd_goto(param_poz_x_y);lcd_putch(alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]/10+'0');
								lcd_goto(param_poz_x_y+1);lcd_putch(alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]%10+'0');
								__delay_ms(200);
							}
						}
						if(!RIGHT_BUTTON_PIN) {
							if(debounce_buttons_function(RIGHT_BUTTON_PIN)) {	
								switch(idx_rtc_vars) {  
									case 1:if(alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]<59)alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]++;break;
									case 2:if(alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]<23)alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]++;break;
									case 3:if(alarm_tmr1_vars[set_lrm_fnc][3]<(31-3*(alarm_tmr1_vars[set_lrm_fnc][4]==2)-1*(alarm_tmr1_vars[set_lrm_fnc][4]>=3&&((alarm_tmr1_vars[set_lrm_fnc][4]-1)%2))+1*((alarm_tmr1_vars[set_lrm_fnc][5]%4)==0)))
													alarm_tmr1_vars[set_lrm_fnc][3]++;
													break;
									case 4:if(alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]<12)alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]++;break;
									case 5: if(alarm_tmr1_vars[set_lrm_fnc][5]<99)alarm_tmr1_vars[set_lrm_fnc][5]++;break;
								}
								lcd_goto(param_poz_x_y);lcd_putch(alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]/10+'0');
								lcd_goto(param_poz_x_y+1);lcd_putch(alarm_tmr1_vars[set_lrm_fnc][idx_rtc_vars]%10+'0');
								__delay_ms(200);
							 }
						}
					}
					if(!set_lrm_fnc)convert_rtc_variables();
				}
	}
	if(tmr1_time_set==0) {
		if(set_lrm_fnc == 0){
			alarm_tmr1_vars[0][0]=0;
			timer1_tick=0;
		}
		else set_lrm_fnc = 0;
	tmr1_time_set=1;
	TMR1ON=1;
	TMR1=64536;//tmr1h+tmr1L=> 16 bits => 
	}
}

/*
void functionality_5_Alarm_Clock_DS1307_Set()
{
	ds1307_minute = convert_fr_decimal_to_bcd(ds1307_minute);
	ds1307_hour = convert_fr_decimal_to_bcd(ds1307_hour);
	ds1307_day = convert_fr_decimal_to_bcd(ds1307_day);
	ds1307_month = convert_fr_decimal_to_bcd(ds1307_month);
	ds1307_year = convert_fr_decimal_to_bcd(ds1307_year);
	I2C_start();         // start I2C
    I2C_write(0xD0);     // RTC chip address
    I2C_write(0);        // send register address
    I2C_write(0);        // reset seconds and start oscillator
	I2C_write(ds1307_minute);   // write minute value to RTC chip
    I2C_write(ds1307_hour);     // write hour value to RTC chip
    I2C_write(1);        // write day value (not used)
    I2C_write(ds1307_day);    // write date value to RTC chip
    I2C_write(ds1307_month);    // write month value to RTC chip
    I2C_write(ds1307_year);     // write year value to RTC chip
    I2C_stop();          // stop I2C
	__delay_ms(200);
	ds1307_rtc_display_date_time();
}

void  functionality_5_Alarm_Clock_DS1307_Read()
{
	I2C_start();           // start I2C
	I2C_write(0xD0);       // RTC chip address
	I2C_write(0);          // send register address
	I2C_repeated_start();  // restart I2C
	I2C_write(0xD1);       // initialize data read
	ds1307_second = I2C_read(1);  // read seconds from register 0
	ds1307_minute = I2C_read(1);  // read minutes from register 1
	ds1307_hour   = I2C_read(1);  // read hour from register 2
	I2C_read(1);           // read day from register 3 (not used)
	ds1307_day  = I2C_read(1);  // read date from register 4
	ds1307_month  = I2C_read(1);  // read month from register 5
	ds1307_year   = I2C_read(0);  // read year from register 6
	I2C_stop();            // stop I2C
	ds1307_rtc_display_date_time();    // print time & date								 
	__delay_ms(50);   // wait 50 ms
}
*/
char debounce_buttons_function (char button_debounce) {
  char count_debounce = 0;
  for(char debounce_variable = 0; debounce_variable< 5; debounce_variable++) {
	if (button_debounce == 0) count_debounce++;
	__delay_ms(10);
  }
  if(count_debounce > 2)  return 1;
  else return 0;
}

void print_text_to_lcd(char *row1 , char *row2)
{		
	lcd_clear();
	__delay_ms(10);
	lcd_goto(0x80);
	lcd_puts(row1);
	lcd_goto(0xC0);
	lcd_puts(row2);
}
void convert_rtc_variables(void)
{
	clock_date_tmr1[6]=alarm_tmr1_vars[0][3]/10+'0';
	clock_date_tmr1[7]=alarm_tmr1_vars[0][3]%10+'0';
	clock_date_tmr1[9]=alarm_tmr1_vars[0][4]/10+'0';
	clock_date_tmr1[10]=alarm_tmr1_vars[0][4]%10+'0';
	clock_date_tmr1[14]=alarm_tmr1_vars[0][5]/10+'0';
	clock_date_tmr1[15]=alarm_tmr1_vars[0][5]%10+'0';
	clock_time_tmr1[6]=alarm_tmr1_vars[0][2]/10+'0';
	clock_time_tmr1[7]=alarm_tmr1_vars[0][2]%10+'0';
	clock_time_tmr1[9]=alarm_tmr1_vars[0][1]/10+'0';
	clock_time_tmr1[10]=alarm_tmr1_vars[0][1]%10+'0';
	clock_time_tmr1[12]=alarm_tmr1_vars[0][0]/10+'0';
	clock_time_tmr1[13]=alarm_tmr1_vars[0][0]%10+'0';
}

